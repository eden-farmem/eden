diff --git a/drivers/net/ixgbe/ixgbe_rxtx.c b/drivers/net/ixgbe/ixgbe_rxtx.c
index 6cfbb582e2..c7e41c9471 100644
--- a/drivers/net/ixgbe/ixgbe_rxtx.c
+++ b/drivers/net/ixgbe/ixgbe_rxtx.c
@@ -556,10 +556,10 @@ tx_desc_ol_flags_to_cmdtype(uint64_t ol_flags)
 
 /* Default RS bit threshold values */
 #ifndef DEFAULT_TX_RS_THRESH
-#define DEFAULT_TX_RS_THRESH   32
+#define DEFAULT_TX_RS_THRESH   64
 #endif
 #ifndef DEFAULT_TX_FREE_THRESH
-#define DEFAULT_TX_FREE_THRESH 32
+#define DEFAULT_TX_FREE_THRESH 64
 #endif
 
 /* Reset transmit descriptors after they have been used */
@@ -2491,6 +2491,41 @@ static const struct ixgbe_txq_ops def_txq_ops = {
 	.reset = ixgbe_reset_tx_queue,
 };
 
+static uint16_t
+install_txq_ctx(struct ixgbe_tx_queue *txq, uint16_t slot,
+	const uint64_t flags, const union ixgbe_tx_offload tx_offload)
+{
+
+	/* This must be called before any packets are placed in the ring */
+	ASSERT(txq->tx_tail == 0);
+	ASSERT(((struct ixgbe_tx_entry_v *)txq->sw_ring_v)->mbuf == NULL);
+	ASSERT(txq->nb_tx_free >= txq->tx_free_thresh);
+	ASSERT(txq->nb_tx_desc > 0);
+	ASSERT(txq->nb_tx_free >= 1);
+	ASSERT(slot < IXGBE_CTX_NUM);
+
+
+	uint64_t tx_ol_req = flags & IXGBE_TX_OFFLOAD_MASK;
+
+	volatile union ixgbe_adv_tx_desc *txr = txq->tx_ring;
+	volatile struct ixgbe_adv_tx_context_desc *ctx_txd;
+	ctx_txd = (volatile struct ixgbe_adv_tx_context_desc *)txr;
+
+	txq->ctx_curr = slot;
+	ixgbe_set_xmit_ctx(txq, ctx_txd, tx_ol_req,
+		tx_offload, NULL);
+
+	txq->nb_tx_used = (uint16_t)(txq->nb_tx_used + 1);
+	txq->nb_tx_free = (uint16_t)(txq->nb_tx_free - 1);
+
+	PMD_TX_LOG(DEBUG, "port_id=%u queue_id=%u tx_tail=%u nb_tx=%u",
+		   (unsigned) txq->port_id, (unsigned) txq->queue_id,
+		   (unsigned) 1, (unsigned) 1);
+	IXGBE_PCI_REG_WRITE_RELAXED(txq->tdt_reg_addr, 1);
+	txq->tx_tail = 1;
+	return 1;
+}
+
 /* Takes an ethdev and a queue and sets up the tx function to be used based on
  * the queue parameters. Used in tx_queue_setup by primary process and then
  * in dev_init by secondary process when attaching to an existing ethdev.
@@ -2499,7 +2534,7 @@ void __rte_cold
 ixgbe_set_tx_function(struct rte_eth_dev *dev, struct ixgbe_tx_queue *txq)
 {
 	/* Use a simple Tx queue (no offloads, no multi segs) if possible */
-	if ((txq->offloads == 0) &&
+	if ((txq->offloads & ~(DEV_TX_OFFLOAD_IPV4_CKSUM | DEV_TX_OFFLOAD_UDP_CKSUM | DEV_TX_OFFLOAD_TCP_CKSUM)) == 0 &&
 #ifdef RTE_LIB_SECURITY
 			!(txq->using_ipsec) &&
 #endif
@@ -2766,6 +2801,15 @@ ixgbe_dev_tx_queue_setup(struct rte_eth_dev *dev,
 
 	dev->data->tx_queues[queue_idx] = txq;
 
+	uint64_t olflags = PKT_TX_IP_CKSUM | PKT_TX_IPV4 | PKT_TX_TCP_CKSUM;
+	union ixgbe_tx_offload tx_offloads;
+	memset(&tx_offloads, 0, sizeof(tx_offloads));
+	tx_offloads.l2_len = RTE_ETHER_HDR_LEN;
+	tx_offloads.l3_len = sizeof(struct rte_ipv4_hdr);
+	tx_offloads.l4_len = sizeof(struct rte_tcp_hdr);
+
+	if (install_txq_ctx(txq, 0, olflags, tx_offloads) != 1)
+		return -EINVAL;
 
 	return 0;
 }
diff --git a/drivers/net/ixgbe/ixgbe_rxtx.h b/drivers/net/ixgbe/ixgbe_rxtx.h
index 6d2f7c9da3..0c4a2f183b 100644
--- a/drivers/net/ixgbe/ixgbe_rxtx.h
+++ b/drivers/net/ixgbe/ixgbe_rxtx.h
@@ -27,14 +27,14 @@
 #define	IXGBE_MIN_RING_DESC	32
 #define	IXGBE_MAX_RING_DESC	4096
 
-#define RTE_PMD_IXGBE_TX_MAX_BURST 32
-#define RTE_PMD_IXGBE_RX_MAX_BURST 32
+#define RTE_PMD_IXGBE_TX_MAX_BURST 64
+#define RTE_PMD_IXGBE_RX_MAX_BURST 64
 #define RTE_IXGBE_TX_MAX_FREE_BUF_SZ 64
 
 #define RTE_IXGBE_DESCS_PER_LOOP    4
 
 #if defined(RTE_ARCH_X86) || defined(RTE_ARCH_ARM)
-#define RTE_IXGBE_RXQ_REARM_THRESH      32
+#define RTE_IXGBE_RXQ_REARM_THRESH      64
 #define RTE_IXGBE_MAX_RX_BURST          RTE_IXGBE_RXQ_REARM_THRESH
 #endif
 
diff --git a/drivers/net/ixgbe/ixgbe_rxtx_vec_common.h b/drivers/net/ixgbe/ixgbe_rxtx_vec_common.h
index a97c27189b..130c6fcadd 100644
--- a/drivers/net/ixgbe/ixgbe_rxtx_vec_common.h
+++ b/drivers/net/ixgbe/ixgbe_rxtx_vec_common.h
@@ -94,8 +94,8 @@ ixgbe_tx_free_bufs(struct ixgbe_tx_queue *txq)
 	 * tx_next_dd - (tx_rs_thresh-1)
 	 */
 	txep = &txq->sw_ring_v[txq->tx_next_dd - (n - 1)];
-	m = rte_pktmbuf_prefree_seg(txep[0].mbuf);
-	if (likely(m != NULL)) {
+	if (likely(txep[0].mbuf &&
+			(m = rte_pktmbuf_prefree_seg(txep[0].mbuf)) != NULL)) {
 		free[0] = m;
 		nb_free = 1;
 		for (i = 1; i < n; i++) {
diff --git a/drivers/net/ixgbe/ixgbe_rxtx_vec_sse.c b/drivers/net/ixgbe/ixgbe_rxtx_vec_sse.c
index 90c076825a..835335a17d 100644
--- a/drivers/net/ixgbe/ixgbe_rxtx_vec_sse.c
+++ b/drivers/net/ixgbe/ixgbe_rxtx_vec_sse.c
@@ -636,7 +636,20 @@ static inline void
 vtx1(volatile union ixgbe_adv_tx_desc *txdp,
 		struct rte_mbuf *pkt, uint64_t flags)
 {
-	__m128i descriptor = _mm_set_epi64x((uint64_t)pkt->pkt_len << 46 |
+	/* Set Packet Length */
+	uint64_t top_flags =  (uint64_t)pkt->pkt_len << 46;
+
+	/* Set IXGBE_TXD_POPTS_IXSM */
+	top_flags |= (pkt->ol_flags & PKT_TX_IP_CKSUM) >> 14;
+	RTE_BUILD_BUG_ON(
+		PKT_TX_IP_CKSUM >> 14 != (uint64_t)IXGBE_TXD_POPTS_IXSM << 40);
+
+	/* Set IXGBE_TXD_POPTS_TXSM */
+	top_flags |= (pkt->ol_flags & PKT_TX_TCP_CKSUM) >> 11;
+	RTE_BUILD_BUG_ON(
+		PKT_TX_TCP_CKSUM >> 11 != (uint64_t)IXGBE_TXD_POPTS_TXSM << 40);
+
+	__m128i descriptor = _mm_set_epi64x(top_flags |
 			flags | pkt->data_len,
 			pkt->buf_iova + pkt->data_off);
 	_mm_store_si128((__m128i *)&txdp->read, descriptor);
diff --git a/drivers/net/mlx5/linux/mlx5_verbs.c b/drivers/net/mlx5/linux/mlx5_verbs.c
index 540ce32990..7699598d2d 100644
--- a/drivers/net/mlx5/linux/mlx5_verbs.c
+++ b/drivers/net/mlx5/linux/mlx5_verbs.c
@@ -280,7 +280,7 @@ mlx5_rxq_ibv_wq_create(struct rte_eth_dev *dev, uint16_t idx)
 		.max_sge = 1 << rxq_data->sges_n,
 		.pd = priv->sh->pd,
 		.cq = rxq_obj->ibv_cq,
-		.comp_mask = IBV_WQ_FLAGS_CVLAN_STRIPPING | 0,
+		.comp_mask = IBV_WQ_INIT_ATTR_FLAGS | IBV_WQ_FLAGS_CVLAN_STRIPPING | 0,
 		.create_flags = (rxq_data->vlan_strip ?
 				 IBV_WQ_FLAGS_CVLAN_STRIPPING : 0),
 	};
diff --git a/drivers/net/mlx5/mlx5_custom.h b/drivers/net/mlx5/mlx5_custom.h
new file mode 100644
index 0000000000..925721de96
--- /dev/null
+++ b/drivers/net/mlx5/mlx5_custom.h
@@ -0,0 +1,8 @@
+
+#ifndef RTE_PMD_MLX5_CUSTOM_H
+#define RTE_PMD_MLX5_CUSTOM_H
+
+void *mlx5_manual_reg_mr(uint8_t port_id, void *addr, size_t length, uint32_t *lkey_out);
+void mlx5_manual_dereg_mr(void *ibv_mr);
+
+#endif /* RTE_PMD_MLX5_CUSTOM_H */
diff --git a/drivers/net/mlx5/mlx5_mr.c b/drivers/net/mlx5/mlx5_mr.c
index 8b20ee3f83..7b933e7402 100644
--- a/drivers/net/mlx5/mlx5_mr.c
+++ b/drivers/net/mlx5/mlx5_mr.c
@@ -546,3 +546,20 @@ mlx5_mr_update_mp(struct rte_eth_dev *dev, struct mlx5_mr_ctrl *mr_ctrl,
 	}
 	return data.ret;
 }
+
+void *
+mlx5_manual_reg_mr(uint8_t port_id, void *addr, size_t length, uint32_t *lkey_out)
+{
+	struct rte_eth_dev *dev = &rte_eth_devices[port_id];
+	struct mlx5_priv *priv = dev->data->dev_private;
+	struct ibv_mr *ibv_mr = mlx5_glue->reg_mr(priv->sh->pd, addr, length, IBV_ACCESS_LOCAL_WRITE);
+	if (ibv_mr && lkey_out) *lkey_out = rte_cpu_to_be_32(ibv_mr->lkey);
+
+	return ibv_mr;
+}
+
+void
+mlx5_manual_dereg_mr(void *ibv_mr)
+{
+	mlx5_glue->dereg_mr(ibv_mr);
+}
diff --git a/drivers/net/mlx5/mlx5_mr.h b/drivers/net/mlx5/mlx5_mr.h
index 4a7fab6df2..b0820ce674 100644
--- a/drivers/net/mlx5/mlx5_mr.h
+++ b/drivers/net/mlx5/mlx5_mr.h
@@ -16,6 +16,7 @@
 #include <rte_memory.h>
 
 #include <mlx5_common_mr.h>
+#include "mlx5_custom.h"
 
 /* First entry must be NULL for comparison. */
 #define mlx5_mr_btree_len(bt) ((bt)->len - 1)
diff --git a/drivers/net/mlx5/mlx5_rxtx.c b/drivers/net/mlx5/mlx5_rxtx.c
index d12d746c2f..6cb79d58f5 100644
--- a/drivers/net/mlx5/mlx5_rxtx.c
+++ b/drivers/net/mlx5/mlx5_rxtx.c
@@ -1807,7 +1807,7 @@ removed_rx_burst(void *dpdk_txq __rte_unused,
  * stubs are needed for linkage when those are not included outside of this file
  * (e.g.  mlx5_rxtx_vec_sse.c for x86).
  */
-
+#if 0
 __rte_weak uint16_t
 mlx5_rx_burst_vec(void *dpdk_txq __rte_unused,
 		  struct rte_mbuf **pkts __rte_unused,
@@ -1835,6 +1835,7 @@ mlx5_check_vec_rx_support(struct rte_eth_dev *dev __rte_unused)
 {
 	return -ENOTSUP;
 }
+#endif
 
 /**
  * Free the mbufs from the linear array of pointers.
diff --git a/drivers/net/mlx5/mlx5_rxtx.h b/drivers/net/mlx5/mlx5_rxtx.h
index 7989a50403..5a2119fd6e 100644
--- a/drivers/net/mlx5/mlx5_rxtx.h
+++ b/drivers/net/mlx5/mlx5_rxtx.h
@@ -574,6 +574,10 @@ mlx5_rx_addr2mr(struct mlx5_rxq_data *rxq, uintptr_t addr)
 
 #define mlx5_rx_mb2mr(rxq, mb) mlx5_rx_addr2mr(rxq, (uintptr_t)((mb)->buf_addr))
 
+struct mem_info {
+	uint32_t lkey;
+};
+
 /**
  * Query LKey from a packet buffer for Tx. If not found, add the mempool.
  *
@@ -586,22 +590,10 @@ mlx5_rx_addr2mr(struct mlx5_rxq_data *rxq, uintptr_t addr)
  *   Searched LKey on success, UINT32_MAX on no match.
  */
 static __rte_always_inline uint32_t
-mlx5_tx_mb2mr(struct mlx5_txq_data *txq, struct rte_mbuf *mb)
+mlx5_tx_mb2mr(struct mlx5_txq_data *txq __rte_unused, struct rte_mbuf *mb)
 {
-	struct mlx5_mr_ctrl *mr_ctrl = &txq->mr_ctrl;
-	uintptr_t addr = (uintptr_t)mb->buf_addr;
-	uint32_t lkey;
-
-	/* Check generation bit to see if there's any change on existing MRs. */
-	if (unlikely(*mr_ctrl->dev_gen_ptr != mr_ctrl->cur_gen))
-		mlx5_mr_flush_local_cache(mr_ctrl);
-	/* Linear search on MR cache array. */
-	lkey = mlx5_mr_lookup_lkey(mr_ctrl->cache, &mr_ctrl->mru,
-				   MLX5_MR_CACHE_N, addr);
-	if (likely(lkey != UINT32_MAX))
-		return lkey;
-	/* Take slower bottom-half on miss. */
-	return mlx5_tx_mb2mr_bh(txq, mb);
+	struct mem_info *m = (struct mem_info *)(((char *) mb) + sizeof(struct rte_mbuf));
+	return m->lkey;
 }
 
 /**
diff --git a/drivers/net/mlx5/version.map b/drivers/net/mlx5/version.map
index 82a32b53da..9490857fe2 100644
--- a/drivers/net/mlx5/version.map
+++ b/drivers/net/mlx5/version.map
@@ -1,4 +1,9 @@
 DPDK_21 {
+	global:
+
+	mlx5_manual_reg_mr;
+	mlx5_manual_dereg_mr;
+
 	local: *;
 };
 
